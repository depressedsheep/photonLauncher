API for usb commands across USB endpoint 1:

CLOCKCHIP_WRITE

sends a command via the SPI interface into the clock generation chip. Argument
structure of the USB EP1 OUT packet:
Offset Name  content
  0    len1  Lengh of USB packet in bytes, including header (>6?)
  1    cmd   command token, here: CLOCKCHIP_WRITE
  2    len2  SPI packet payload byte length (>=1?)
  3    N/A   (reserved)
  4    SP1   SPI most signifiant command byte
  5    SP2   SPI least significant command byte
  6    SPD   SPI first data byte
 ....

If the limitation of a USB packet is 64 bytes for EP1, then the following
limitations apply:
  len1 <= 64, thus len2 <= 58

CLOCKCHIP_READ:
sends a read command via the SPI interface into the clock generation
chip. Argument structure of the USB EP1 OUT packet:
Offset Name  content
  0    len1  Lengh of USB packet in bytes, including header. Always 6. 
  1    cmd   command token, here: CLOCKCHIP_READ
  2    len2  Data bytes to read back (>=1?)
  3    N/A   (reserved)
  4    SP1   SPI most signifiant command byte
  5    SP2   SPI least significant command byte

The device then returns the following bare packet:
Offset Name  content
  0    SP1   SPI most signifiant command byte (readback after firmware edit)
  1    SP2   SPI least significant command byte (readback after firmware edit)
  2    first byte read back
  3    .... next bytes returned if any


----------------------------------------------------------
API for the Linux device driver via ioctl commands:

CLOCKCHIP_WRITE:

ioctl(filehandle, CLOCKCHIP_WRITE, *buffer), where *buffer is a pointer to the
following structure:

Offset Name/meaning
  0    unsigned char len; /* SPI packet payload length */
  1    unsigned char SP1; /* SPI most significant command byte */
  2    unsigned char SP2; /* SPI least significant command byte */
  3    char payloaddata[]; /* array of payload data */

if the argument is too long, an error (E2BIG) is generated and returned with
the ioctl call, otherwise return value is zero.

CLOCKCHIP_READ:

ioctl(filehandle, CLOCKCHIP_READ, *buffer), where *buffer is a pointer to the
following structure:
Offset Name/meaning
  0    unsigned char len; /* SPI packet payload/readback data length in bytes */
  1    unsigned char SP1; /* SPI most significant command byte */
  2    unsigned char SP2; /* SPI least significant command byte */
  3    char payloaddata[]; /* array of payload data */

For the call, only positions 0..2 need to be populated; the call modifiies the
entries as follows:
Offset  Name/meaning
  0    len: Contains the number of bytes returned by the SPI
  1    SP1: MSB of commands, as modified by the firmware
  2    SP2: LSB of commands, as modified by the firmware
  3    payloaddata[]: Here will be the returned read back data


