This directory contains a simple version of the usb driver for the DDS card
and a simple example application to talk to program the chip.

The large bandwidth data transfer is established with a write method on the
user side (blocking? need to find out...)via the EP2out endpoint, a few
parameters can be adjusted and requested with ioctl commands using the EP1
endpoints; see firware (usbdds) for details.

chk, 26.9.09

Directory content

2.6/      directory containing the kernel driver and corresponding support
	  files. The usbdds_io.h contains the ioctl
	  definitions needed for any application talking to the device.

hotplug/  directory containing the sources for the hotplugging method.

apps/     directory with some test applications. The interesting one is the
	  dds_encode, a command parser to generate control sequences for the
	  DDS in a human-readable form,  or via readable scripts. Read the
	  comment section at the beginning of the source code, it has a man
	  page for that program and some examples.

apps/listplay  Temporary code to debug the listplay option in firmware 2.0

Makefile  Script to do what you most likely want to do with these files


Installation:

Before you start to install or compile anything, make sure the directory is
located in a reasonably stable place, and that this directory is not very
likely to removed to any other place as the driver will be loaded from
hotplugging out of this directory structure. In our lab, this directory should
reside in /home/qitlab/programs/.

Then, you have to compile the driver itself. Remember that for the moment,
there is only a port for a 2.6 kernel, and no backport for the 2.4 machines
(not sure I want to do this anyway). The compilation is done from the main
driver directory by saying

        make

Then, the hotplugging machinery needs to be installed. By now, all our systems
use the udev method, which is a generalized driver insertion and dynamic
device generation tool, so this is the only impemented method.

You install the hotplugging stuff with the command

    make udev

This installs a udev rule file and a device driver loader into the directory
/etc/udev/rules.d/ of a unified hotplugging mechanism used in several
distributions. It will ask you for a root password for the copying of the rule
into the /etc/udev/rules.d directory.


By now, everything should be done. You can check the success of the endeavour
by plugging in a device and looking for a newly created device file
/dev/ioboards/ddsx, where x is a device number starting from 0. Check also
that the /dev/ddsx file has the correct group; it will inherit the group from
the group under which the driver files were compiled. For a more unique access
to the device, there is also a link named /dev/ioboards/dds_%serial created,
where %serial is the serial string in the usb device.

See .c driver file for details.

Device functionality: 

The driver provides a write method to dump a sequence of 8bit wide words onto
the parallel output of the FX2 usb chip, serializing it partly for the DDS
chip (this is transparent to the user).
Some IOCTL commands are supplied to control the device (aka reset it, and
retreive some identification data fro the firmware, but at the moment this is
not interesting. The blocking/nonblocking options are hardly an issue since
the control words are quite short.

The simplest way to operate the device is just to copy a file containing the
control sequence into the device /dev/ioboards/dds0 or whatever the number is.
Be aware that if there is a loss of synchronization with the programing
sequence, or a bug in the configuration content, you may have to reboot the
chip to get it into a sane state again. The reset_dds program should do that.

By now there are ways to send out clusters of configuration files,
synchronized by either the SYNC clock, or the internal clock of the USB chip.
This should allow one-time patterns with an arbitrary envelope to be played,
possibly being started with an external trigger signal (this needs to be still
tested). Downside here is that the configuration data needs to be constantly
supplied by the host PC, which may require some coordination.

A version to have a configuration lookup table with an external clockable table
increment ("listplay mode") is in progress.


Status:
	Inherit permissions from compiling user 17.9.10chk
        Exploring listplay mode 7.2.10chk
	Cleanup of reset program in apps
