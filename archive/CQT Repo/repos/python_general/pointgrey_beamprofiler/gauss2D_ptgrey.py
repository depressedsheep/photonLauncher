#! /usr/bin/env python2

"""
Fitting of a beam profile using a 2D gaussian profile from a
raw file obtained from the Point Grey camera.
It only works for greyscale cameras, no colors yet.
http://ww2.ptgrey.com/USB2/chameleon

All calculations are in pixel units, only the final results are converted
into mm (yes, no meters, mm) at
printing time

When used from CLI, it has the following usage

July 2014
Alessandro Cere

"""

import numpy as np
import pylab as plt
import argparse

import scipy.optimize as opt
import scipy.ndimage as snd
from lmfit import Model, Parameters


# I assume a square pixel
pixel_size = 3.75e-3


def twoD_Gaussian(x, y, amplitude, xo, yo, sigma_x, sigma_y, theta, offset):
    """
    Model function for the 2D gaussian distribution

    :param amplitude:
    :param xo, yo: coordinates of the center of the distribution
    :param sigma_x: one of the widths of the gaussian
    :param sigma_y: the other width
    :param theta: angle of the ellipticity
    :param offset: background offset
    :return:
    """
    xo = float(xo)
    yo = float(yo)
    a = (np.cos(theta)**2) / (2 * sigma_x**2) + \
        (np.sin(theta)**2) / (2 * sigma_y**2)
    b = -(np.sin(2 * theta)) / (4 * sigma_x**2) + \
        (np.sin(2 * theta)) / (4 * sigma_y**2)
    c = (np.sin(theta)**2) / (2 * sigma_x**2) + \
        (np.cos(theta)**2) / (2 * sigma_y**2)
    g = offset + amplitude * \
        np.exp(- (a * ((x - xo)**2) + 2 * b * (x - xo)
                  * (y - yo) + c * ((y - yo)**2)))
    return g.ravel()

fit_mod = Model(twoD_Gaussian)


class Profile():

    def __init__(self):
        self.data = np.array([])
        self.height = 0
        self.width = 0
        self.bit_depth = np.uint8
        self.cmd = [0, 0]
        self.fit_data = np.array([])
        self.popt = []
        self.pcov = []
        self.sigma_0 = 0
        self.sigma_1 = 0
        self.angle = 0

    def raw2array(self, raw_filename, bit_depth=8):
        """
        file to read the binary RAW file generated by flycap
        or coriander into a numpy 2D array
        :param raw_filename: name of the raw file
        :param bit_depth: specify if 8 or 16 bits
        :return: it returns a numpy 2D array
        """
        if bit_depth == 16:
            self.bit_depth = np.uint16
        else:
            self.bit_depth = np.uint8
        data = np.fromfile(raw_filename, dtype=self.bit_depth)
        self.width = np.sqrt(len(data) / 12) * 4
        self.height = np.sqrt(len(data) / 12) * 3
        self.data = data.reshape(self.height, self.width)

    def frame2array(self, frame):
        """
        Initializes the beam profile from a frame
        captured using opencv (the cv2 backend)
        :param frame: frame captured with cv2 or any other 2D numpy array
        """
        self.height, self.width = frame.shape
        self.data = frame
        self.bit_depth = frame.dtype

    def center_of_mass(self):
        """
        Function to calculate the center of mass of the distribution.
        Hopefully this shouldn't fall to far
        from the center of the Gaussian distribution
        """
        hist, bins = np.histogram(self.data.ravel(), normed=True, bins=100)
        threshold = bins[np.cumsum(hist) * (bins[1] - bins[0]) > 0.8][0]
        data_masked = np.ma.masked_less(self.data, threshold)
        self.cmd = snd.center_of_mass(data_masked)
        return self.cmd

    def twoD_Gaussian_fit(self):
        """
        fitting of the gaussian distribution using the least square method.
        the relevant parameters are returned as properties of the object
        """
        v_dim, h_dim = self.data.shape
        # Start finding the parameters for the fit.
        # First one: amplitude
        amp = np.max(self.data)
        # then the position of the center
        y0, x0 = self.center_of_mass()
        # the initial guess for the widths and angle can be done better...
        sigma_x = 100
        sigma_y = 100
        theta = 0
        offset = np.median(self.data)
        initial_guess = [amp, x0, y0, sigma_x, sigma_y, theta, offset]
        x = np.linspace(0, h_dim - 1, h_dim)
        y = np.linspace(0, v_dim - 1, v_dim)
        x, y = np.meshgrid(x, y)
        self.popt, self.pcov = opt.curve_fit(
            twoD_Gaussian, (x, y), self.data.ravel(), p0=initial_guess)
        self.sigma_0 = float(self.popt[3]) * pixel_size
        self.sigma_1 = float(self.popt[4]) * pixel_size
        self.fit_data = twoD_Gaussian(
            (x, y), *self.popt).reshape(self.data.shape)
        self.angle = np.mod(float(self.popt[5]), np.pi)

    def Gauss_fit_2(self):
        """
        fitting of the gaussian distribution using the least square method.
        the relevant parameters are returned as properties of the object
        """
        v_dim, h_dim = self.data.shape

        # Start finding the parameters for the fit.
        params = Parameters()
        params.add('amp',   value=np.max(self.data), min=0)
        params.add('y0', value=y0)
        params.add('x0', value=x0)
        params.add('sigma_y', value=100)
        params.add('sigma_x', value=100)
        params.add('offset', value=np.median(self.data), min=0)
        params.add('theta', value=0)
        result = fit_mod.fit(self.data.ravel(), x=x, y=y, params)


if __name__ == "__main__":
    # let's take care of the CLI arguments:
    parser = argparse.ArgumentParser(
        description='Show the content of a RAW image file and\n'
                    'optionally fits a 2D gaussian distribution to it')

    parser.add_argument('inputfile',
                        metavar='input',
                        type=str,
                        help='Input RAW file')

    parser.add_argument('-b',
                        metavar='bit depth',
                        type=int,
                        default=8,
                        help='bit depth of the image, either 8 or 16 bit')

    parser.add_argument('-fit',
                        action="store_true",
                        help='Option to run a 2D gaussian fit')

    args = parser.parse_args()

    inputfile = args.inputfile

    # initialize an element of the Profile class
    b_waist = Profile()

    # Fill the data from a raw file
    b_waist.raw2array(inputfile, bit_depth=args.b)

    if args.fit:
        # fit the data with a 2D gaussian fit and print the results
        b_waist.twoD_Gaussian_fit()
        print(
            'Amplitude: {0:.0f}\n'
            'Center: ({1:.2f}, {2:.2f}) mm\n'
            'Width_0: {3:.3f} mm\n'
            'Width_1: {4:.3f} mm\n'
            'Angle: {5:.1f} deg\n'
            'Bground: {6:.0f}'.format(
                b_waist.popt[0],
                b_waist.popt[1] * pixel_size,
                b_waist.popt[2] * pixel_size,
                b_waist.sigma_0,
                b_waist.sigma_1,
                b_waist.angle,
                b_waist.popt[6] / np.pi * 180))

        ps = pixel_size * 1e3
        plt.imshow(b_waist.data, cmap=plt.cm.jet,
                   origin='lower', interpolation='none',
                   extent=[0, b_waist.width * ps, 0, b_waist.height * ps])
        plt.colorbar()
        plt.contour(b_waist.fit_data, 8, colors='w',
                    extent=[0, b_waist.width * ps, 0, b_waist.height * ps])

        x_line_0 = np.linspace(b_waist.popt[1] * ps - b_waist.sigma_0 * 3e3 * np.cos(b_waist.angle),
                               b_waist.popt[1] * ps + b_waist.sigma_0 * 3e3 * np.cos(b_waist.angle), 3)
        x_line_1 = np.linspace(b_waist.popt[1] * ps - b_waist.sigma_1 * 3e3 * np.sin(b_waist.angle),
                               b_waist.popt[1] * ps + b_waist.sigma_1 * 3e3 * np.sin(b_waist.angle), 3)
        plt.plot(x_line_0, np.sin(b_waist.angle) *
                 (x_line_0 - b_waist.popt[1] * ps) + b_waist.popt[2] * ps, 'r')
        plt.plot(x_line_1, -1 / np.sin(b_waist.angle) *
                 (x_line_1 - b_waist.popt[1] * ps) + b_waist.popt[2] * ps, 'r')

    else:
        # open a new figure window and plot the image as a density plot
        plt.figure()
        plt.imshow(b_waist.data, origin='lower', interpolation='none',
                   extent=[0, b_waist.width * pixel_size * 1e3, 0,
                           b_waist.height * pixel_size * 1e3])
        plt.colorbar()
    plt.xlabel('horizontal axis (um)')
    plt.ylabel('vertical axis (um)')
    plt.grid(linewidth=2, c='g')
    # plt.tight_layout()
    plt.show()


def Gauss_fit_2(self):
    """
    fitting of the gaussian distribution using the least square method.
    the relevant parameters are returned as properties of the object
    """
    v_dim, h_dim = waist.data.shape

    # Start finding the parameters for the fit.
    params = Parameters()
    params.add('amp',   value=np.max(waist.data), min=0)
    params.add('y0', value=y0)
    params.add('x0', value=x0)
    params.add('sigma_y', value=100)
    params.add('sigma_x', value=100)
    params.add('offset', value=np.median(self.data), min=0)
    params.add('theta', value=0)
    result = fit_mod.fit(self.data.ravel(), x=x, y=y, params)


